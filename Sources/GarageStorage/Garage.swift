//
//  Garage.swift
//  GarageStorage
//
//  Created by Brian Arnold on 9/11/19.
//  Copyright © 2015-2024 Wellframe. All rights reserved.
//

import Foundation
import CoreData

/// The main interface for parking and retrieving objects. Anything stored at the top level directly must conform to `Codable`, and also conform to either `Hashable`, `Identifiable`, or GarageStorage’s ``Mappable`` protocol.
///
/// The `Garage` is the main object that coordinates activity in GarageStorage. It's called a *garage* because you can park pretty much anything in it, like, you know, a garage. The `Garage` handles the backing Core Data stack, as well as the saving and retrieving of data. You *park* objects in the `Garage`, and *retrieve* them later.
///
/// Any object going into or coming out of the `Garage` must conform to the `Codable` protocol. Some objects may need to also conform to either the `Hashable` protocol, the `Identifiable` protocol (where `ID` is `LosslessStringConvertible`), or the ``Mappable`` convenience protocol (which is `Codable` and `Identifiable where ID == String`) for uniquely identified top-level objects.
public class Garage {
    
    private static let modelName = "GarageStorage"
    
    private let persistentContainer: NSPersistentContainer

    internal var context: NSManagedObjectContext {
        persistentContainer.viewContext
    }
    
    /// An optional delegate for serializing/deserializing stored data. Specify this to add encryption to the stored data.
    public weak var dataEncryptionDelegate: DataEncryptionDelegate?

    /// Autosave is set to true by default, for every operation that causes a change to the underlying Core Data Managed Object Context.
    ///
    /// When set to true, the garage will be saved after any operation that causes a change to the underlying Core Data Managed Object Context, including `park()`, `setSyncStatus()`, and `delete()`. When set to false, `save()` must be called instead, in order to persist those changes. You might want to set this to false to perform batch changes to many objects before saving them all, to optimize performance.
    public var isAutosaveEnabled = true
    
    /// The domain for errors generated by GarageStorage.
    public static let errorDomain = "GSErrorDomain"
    
    internal static func makeError(_ description: String) -> NSError {
        let userInfo = [NSLocalizedDescriptionKey : description]
        return NSError(domain: errorDomain, code: -1, userInfo: userInfo)
    }

    // MARK: - Initializing

    /// A convenience function that returns a `NSPersistentStoreDescription` of type `NSSQLLiteStoreType`, with a URL in the application Documents directory, of the specified store name.
    ///
    /// - parameter storeName: the name of the store, with an appropriate file extension (e.g., ".sqlite") already appended.
    ///
    /// - returns: A `NSPersistentStoreDescription` of type `NSSQLiteStoreType`, with a URL in the application Documents directory, of the specified store name.
    public static func makePersistentStoreDescription(_ storeName: String) -> NSPersistentStoreDescription {
        let applicationDocumentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).last!
        let storeURL = applicationDocumentsDirectory.appendingPathComponent(storeName)
        let description = NSPersistentStoreDescription(url: storeURL)
        description.type = NSSQLiteStoreType
        return description
    }
    
    /// Creates a Garage with a default persistent store coordinator.
    /// This convenience initializer will also load the persistent store.
    /// - parameter garageName: The name of the garage without an extension, which will be used to create a store with the same name, with the default ".sqlite" extension appended.
    public convenience init(named garageName: String) {
        let storeName = "\(garageName).sqlite"
        let description = Garage.makePersistentStoreDescription(storeName)
        self.init(with: [description])
        
        loadPersistentStores { (description, error) in
            if let error {
                print("An error occurred loading persistent store \(description), error: \(error)")
            }
        }
    }
    
    /// Creates a Garage with the specified persistent store descriptions.
    /// This initializer will not immediately load the persistent stores.
    ///
    /// Once the Garage has been initialized, call ``loadPersistentStores(completionHandler:)`` to instruct the Garage to load the persistent stores and complete the creation of the Core Data stack.
    ///
    /// - parameter persistentStoreDescriptions: An array of `NSPersistentStoreDescription` to use in the Garage's Core Data stack.
    public init(with persistentStoreDescriptions: [NSPersistentStoreDescription]) {
        let garageModel = GarageModel().makeModel()
        self.persistentContainer = NSPersistentContainer(name: Garage.modelName, managedObjectModel: garageModel)
        let descriptions = persistentStoreDescriptions
        self.persistentContainer.persistentStoreDescriptions = descriptions
    }
 
    /// Loads the persistent stores, with a completion handler.
    ///
    /// If the Garage has been initialized with persistent store descriptions, this function must be called to instruct the Garage to load the persistent stores and complete the creation of the Core Data stack.
    ///
    /// Once the completion handler has been called, the Garage is fully initialized and is ready for use.
    ///
    /// If there is an error in the loading of the persistent stores, the `Error` will be returned to the completion block, with the associated `NSPersistentStoreDescription`.
    ///
    /// - parameter block: Once the loading of the persistent stores has completed, this block will be executed on the calling thread.
    public func loadPersistentStores(completionHandler block: @escaping (NSPersistentStoreDescription, Error?) -> Void) {
        persistentContainer.loadPersistentStores(completionHandler: block)
    }
    
    // MARK: - Saving
    
    /// Saves all changes to the Garage's persistent store.
    /// Must be called from within context.performAndWait.
    private func saveContext() {
        guard context.hasChanges else { return }
        do {
            try context.save()
        } catch let error as NSError {
            print("Error saving managed object context: \(error), \(error.userInfo)")
        }
    }
        
    /// Saves all changes to the Garage's persistent store. This will not affect in-memory objects. It is not necessary to call this while autosave is enabled.
    ///
    /// This only needs to be called if `isAutosaveEnabled` is set to `false`. No error is returned, but diagnostic text will be output to the console if an error occurs.
    public func save() {
        context.performAndWait {
            saveContext()
        }
    }
    
    /// Checks if autosave is enabled, and if so, performs a save.
    /// Must be called from within context.performAndWait.
    internal func autosave() {
        guard isAutosaveEnabled else { return }
        saveContext()
    }

    /// Encrypts the data using the dataEncryptionDelegate, if specified, otherwise converts the data to a plain string.
    internal func encrypt(_ data: Data) throws -> String {
        return try dataEncryptionDelegate?.encrypt(data) ?? String(data: data, encoding: .utf8)!
    }
    
    /// Decrypts the string using the dataEncryptionDelegate, if specified, otherwise converts the string to plain data.
    internal func decrypt(_ string: String) throws -> Data {
        return try dataEncryptionDelegate?.decrypt(string) ?? string.data(using: .utf8)!
    }

    // MARK: - Parking
    
    /// Returns a new Core Data object with the type and identifier filled in.
    /// Must be called from within context.performAndWait.
    internal func makeCoreDataObject(_ type: String, identifier: String) -> CoreDataObject {
         let newObject = NSEntityDescription.insertNewObject(forEntityName: CoreDataObject.entityName, into: context) as! CoreDataObject
         
         newObject.gs_type = type
         newObject.gs_identifier = identifier
         newObject.gs_creationDate = Date()
         
         return newObject
     }

    // MARK: - Retrieving

    /// Fetches the Core Data object matching the type and identifier, and creates a new object if one has not been created yet.
    /// Must be called from within context.performAndWait.
    internal func retrieveCoreDataObject(for type: String, identifier: String) -> CoreDataObject {
        return fetchObject(for: type, identifier: identifier) ?? makeCoreDataObject(type, identifier: identifier)
    }
    
    /// Fetches an array of Core Data objects matching the type and identifier (if specifed). Returns an empty array if none are found.
    /// Must be called from within context.performAndWait.
    internal func fetchObjects(for type: String, identifier: String?) -> [CoreDataObject] {
        let fetchRequest: NSFetchRequest<CoreDataObject> = CoreDataObject.fetchRequest()
        fetchRequest.predicate = CoreDataObject.predicate(for: type, identifier: identifier)
        let fetchedObjects = try? context.fetch(fetchRequest)
        
        return fetchedObjects ?? []
    }
    
    /// Fetches the first Core Data object matching the type and identifier, and returns nil if not found.
    /// Must be called from within context.performAndWait.
    internal func fetchObject(for type: String, identifier: String?) -> CoreDataObject? {
        let fetchedObjects = fetchObjects(for: type, identifier: identifier)
        
        return fetchedObjects.count > 0 ? fetchedObjects[0] : nil
    }
    
    /// Fetches the first Core Data object matching the type and identifier. Throws an error if not found.
    /// Must be called from within context.performAndWait.
    internal func fetchCoreDataObject(for type: String, identifier: String) throws -> CoreDataObject {
        guard let coreDataObject = fetchObject(for: type, identifier: identifier) else {
            throw Garage.makeError("failed to retrieve object of class: \(type) identifier: \(identifier)")
        }
        return coreDataObject
    }
    
    // MARK: - Deleting
    
    /// Deletes the Core Data object. Used by Garage+Codable.
    /// Must be called from within context.performAndWait.
    internal func deleteCoreDataObject(for typeName: String, identifier: String) throws {
        let coreDataObject = try fetchCoreDataObject(for: typeName, identifier: identifier)
        context.delete(coreDataObject)
    }

    /// Deletes the array of Core Data objects. Used by Garage+Codable and by deleteAllObjects
    /// Must be called from within context.performAndWait.
    internal func deleteAll(_ objects: [CoreDataObject]) {
        guard objects.count > 0 else { return }
        
        for object in objects {
            context.delete(object)
        }
    }
    
    /// Deletes all objects from the Garage and performs an autosave.
    public func deleteAllObjects() {
        context.performAndWait {
            let fetchRequest: NSFetchRequest<CoreDataObject> = CoreDataObject.fetchRequest()
            guard let objects = try? context.fetch(fetchRequest) else { return }
            deleteAll(objects)
            
            autosave()
        }
    }
}
